#!/usr/bin/perl

# Copyright (C) 2010   Keith Amling, keith.amling@gmail.com
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

$| = 1;

use strict;
use warnings;

use FindBin;
use lib "$FindBin::RealBin/../libs";

use Amling::Git::GRD::Exec::Context;
use Amling::Git::GRD::CodeGeneration;
use Amling::Git::GRD::Parser;
use Amling::Git::GRD::Utils;
use Amling::Git::Utils;
use Getopt::Long;

# TODO: no die's!  need to all call common bail() infrastructure so we can reset cleanly, maybe even need to allow expectation to be passed into bail() and bail can give user option to cleanup to meet it and continue...
# TODO: several failures (e.g.  any convert_commitlike, any actual commit (think of empty change!)) could probably stand for more graceful handling
# TODO: correctness in the face of GC?  you'd have to run GRD longer than the cleanup period which is pretty big
# TODO: audit messages before each shell invocation indicating expected state and obvious options
# TODO: help on operations
# TODO: help on commands
# TODO: verbosity levels(?)
# TODO: dry run?
# TODO: make empty commits work damn it (skip them or something)

my %onto_options;
my %head_options;
my %plus_options;
my %minus_options;
my %tree_options;
my $skip_edit;

my @options =
(
    "onto=s" => sub { $onto_options{$_[1]} = 1; $minus_options{$_[1]} = 1; },
    "head=s" => sub { $head_options{$_[1]} = 1; },

    "plus=s" => sub { $plus_options{$_[1]} = 1; },
    "minus=s" => sub { $minus_options{$_[1]} = 1; },

    "tree=s" => sub { $tree_options{$_[1]} = 1; },

    "skip-edit|q" => \$skip_edit,
    "help"   => sub { usage(0); },

);

GetOptions(@options) || usage(1);

# we use "<>" for STDIN very soon
my @args = @ARGV;
@ARGV = ();

if(@args == 0)
{
    # arguments only
}
elsif(@args == 1)
{
    if(!%onto_options)
    {
        $onto_options{$args[0]} = 1;
    }
    $minus_options{$args[0]} = 1;
    $head_options{'HEAD'} = 1;
}
elsif(@args == 2)
{
    if(!%onto_options)
    {
        $onto_options{$args[0]} = 1;
    }
    $minus_options{$args[0]} = 1;
    $head_options{$args[1]} = 1;
}
else
{
    die "Invalid number of extra arguments (" . scalar(@args) . ")";
}

if(scalar(keys(%onto_options)) != 1)
{
    die "Invalid number of onto options (" . scalar(keys(%onto_options)) . ")";
}

my $onto_final = Amling::Git::Utils::convert_commitlike(keys(%onto_options));

my $lines = Amling::Git::GRD::CodeGeneration::generate(\%head_options, \%plus_options, \%minus_options, \%tree_options);

Amling::Git::GRD::Utils::run_shell(0, 0, 0);

my @commands = @{Amling::Git::GRD::Parser::edit_loop($lines, $skip_edit)};
unless(@commands)
{
    print "Nothing to do.\n";
    exit 0;
}

my $ctx = Amling::Git::GRD::Exec::Context->new();

Amling::Git::Utils::run_system("git", "checkout", $onto_final) || die "Cannot checkout $onto_final";

my $ct = scalar(@commands);
my $n = 1;
for my $command (@commands)
{
    print "Interpretting ($n/$ct): " . $command->str() . "\n";
    ++$n;

    $command->execute($ctx);
}

{
    my $branches = $ctx->get('branches', {});
    for my $branch (sort(keys(%$branches)))
    {
        # TODO: backup option...
        print "Updating: $branch => " . $branches->{$branch} . "\n";
        # TODO: better reason
        Amling::Git::Utils::run_system("git", "update-ref", "-m", "GRD", "refs/heads/$branch", $branches->{$branch}) || die "Cannot update $branch";
    }
}

{
    my $head = $ctx->get('head');
    if(defined($head))
    {
        my ($type, $v1) = @$head;

        if($type == 0)
        {
            print "Leaving detached head at $v1.\n";
            Amling::Git::Utils::run_system("git", "checkout", $v1) || die "Cannot checkout $v1";
        }
        elsif($type == 1)
        {
            print "Leaving head at branch $v1.\n";
            Amling::Git::Utils::run_system("git", "checkout", $v1) || die "Cannot checkout $v1";
        }
        else
        {
            die "Unknown head type: $type";
        }
    }
    else
    {
        # TODO: maybe reset to starting point?
        print "No head set?  Leaving wherever.\n";
    }
}

print "Done.\n";
my $grd_level = $ENV{'GRD_LEVEL'};
if($grd_level)
{
    print "Still inside GRD!\n";
    print "GRD level: " . $grd_level . "\n";
}

sub usage
{
    my $ec = shift;

    print <<EOF;
Usage: git-rebase-of-doom <options> [<extra arguments>]
   --onto <commitlike>                Use this as the destination to rebase onto.
   --head <commitlike>                Use this as a source of commits and leave HEAD at their tip.

   --plus <commitlike>                Use this as a source of commits.
   --minus <commitlike>               Use this as a source of commits to exclude.

   --tree <commitlike>                Firklewitz this commit[like].

   --skip-edit | -q                   Skip editting by default.
   --help                             Print this help.

If no extra arguments are provided only the options themselves are used to
construct the rebase.

If one extra argument it is used like normal git-rebase, i.e.  it is used as a
--minus and as an --onto if none is provided and HEAD is used as a --head.

If two extra arguments are provided they're used like normal git-rebase, i.e.
the first is used as a --minus and as an --onto if none is provided and the
second is used as a --head.

Both the one and two extra argument forms act roughly as they do in plain
git-rebase as does the --onto switch so simple examples generally are the same.
For example:

# Rebase the HEAD branch up to the tip of master
git-rebase-of-doom master
git-rebase-of-doom --onto master --head HEAD

# Rebase feature up to the tip of master
git-rebase-of-doom master feature
git-rebase-of-doom --onto master --head feature

# Rebase feature up to the tip of master but exclude commits from dev.
git-rebase-of-doom master feature --minus dev
git-rebase-of-doom --onto master --head feature --minus dev
EOF

    exit $ec;
}
