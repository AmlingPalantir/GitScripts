#!/usr/bin/perl

$| = 1;

use strict;
use warnings;

my $remote = shift || die "No remote?";
my $local_prefix = shift;
defined($local_prefix) || die "No local prefix?";
my $remote_prefix = shift;
defined($remote_prefix) || die "No remote prefix?";

my $combined_prefix;
{
    my $pre = "";
    my $post = "";

    my $v1 = $local_prefix;
    my $v2 = $remote_prefix;
    while(length($v1) && length($v2) && substr($v1, -1) eq substr($v2, -1))
    {
        $post = substr($v1, -1) . $post;
        $v1 = substr($v1, 0, -1);
        $v2 = substr($v2, 0, -1);
    }
    while(length($v1) && length($v2) && substr($v1, 0, 1) eq substr($v2, 0, 1))
    {
        $pre .= substr($v1, 0, 1);
        $v1 = substr($v1, 1);
        $v2 = substr($v2, 1);
    }
    my $mid;
    if(length($v1) == 0 && length($v2) == 0)
    {
        $mid = '';
    }
    else
    {
        $mid = '[' . $v1 . '->' . $v2 . ']';
    }
    $combined_prefix = "$pre$mid$post";
}

my %remote_branches;
{
    open(my $fh, "-|", "git", "ls-remote", "--heads", $remote) || die "Cannot open ls-remote";
    while(my $l = <$fh>)
    {
        chomp $l;
        if($l =~ /^([0-9a-f]{40})\t(.*)$/)
        {
            my ($hash, $ref) = ($1, $2);
            if($ref =~ /^refs\/heads\/\Q$remote_prefix\E(.*)$/)
            {
                my $name = $1;
                $remote_branches{$name} = $hash;
            }
        }
        else
        {
            die "Bad line in ls-remote: $l";
        }
    }
    close($fh) || die "Cannot close ls-remote";
}

my %local_branches;
{
    open(my $fh, "-|", "git", "branch", "-v", "--no-abbrev") || die "Cannot open branch";
    while(my $l = <$fh>)
    {
        chomp $l;
        $l =~ s/^..//;
        next if($l =~ /^\(no branch\)/);
        if($l =~ /^([^ ]*) *([0-9a-f]{40}) .*$/)
        {
            my ($name, $hash) = ($1, $2);
            if($name =~ s/^\Q$local_prefix\E//)
            {
                $local_branches{$name} = $hash;
            }
        }
        else
        {
            die "Bad line in branches: $l";
        }
    }
    close($fh) || die "Cannot close branch";
}

my @specs;
{
    for my $name (keys(%local_branches))
    {
        my $remote_hash = delete $remote_branches{$name};
        my $local_hash = $local_branches{$name};
        if(!defined($remote_hash))
        {
            print "New branch $combined_prefix$name at $local_hash\n";
        }
        elsif($remote_hash ne $local_hash)
        {
            print "Old version of $combined_prefix$name is $remote_hash, will update to $local_hash.\n";
        }
        else
        {
            #print "Matching version of $name at $local_hash, will do nothing.\n";
            next;
        }
        push @specs, "refs/heads/$local_prefix$name:refs/heads/$remote_prefix$name";
    }

    for my $name (keys(%remote_branches))
    {
        my $remote_hash = $remote_branches{$name};
        print "Stale branch $combined_prefix$name at $remote_hash, will delete.\n";
        push @specs, ":refs/heads/$remote_prefix$name";
    }
}

if(@specs)
{
    print "Execing push for update...\n";
    exec("git", "push", $remote, "--force", @specs);
}
else
{
    print "Everything is up to date.\n";
}
